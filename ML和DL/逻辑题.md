## 逻辑题

+ 怎么用randomInt(5)实现randomInt(7)?
	+ randomInt(5)的范围是[1,2,3,4,5]，randomInt(7)的范围是[1,2,3,4,5,6,7]
	+ 用(randomInt(5) - 1)构造等概率整数数组[0,1,2,3,4]
	+ 用(randomInt(5) - 1)*5构造等概率整数数组[0,5,10,15,20]
	+ 上面两个数组可以构造等概率数组[0,1,2,3,4,5,6,7,8,9,...,24]
	+ 选择新数组[0,1,2,3,...,20]%7+1可以构造等概率数组[1,2,3,4,5,6,7]
	+ **类似解法：a*(randomInt(a)-1)，从中选取某些元素并对这些元素取%b+1，则可得到randomInt(b)**
	


+ 在圆周上任意找三个点，求这三个点组成锐角三角形、直角三角形或钝角三角形的概率？(等价于 任取三角形，圆心落在三角形内、外、边上的概率各是多少)
	+ 锐角三角形：1/4
	+ 直角三角形：0
	+ 钝角三角形：3/4
+ 在球面上任取四个点，构成的四面体包含球心的概率是多少？
	+ 1/8

+ 抛一枚均匀的硬币若干次，直到出现连续两次正面向上，所需抛硬币总次数的数学期望是多少？

+ 利用一个随机函数(随机值范围在0-1之间)，对一个长度为N的数组进行等概率随机排列？
	+ **洗牌算法**：将原来的数组进行打散，使原数组的每个数在打散后的数组中的每个位置上等概率的出现。
		+ **等概率证明**：一个元素 m 被放入第 i 个位置的概率 = 前 i-1 个位置选择元素时没有选中 m 的概率 * 第 i 个位置选中 m 的概率
			+ P = (n-1/n)*(n-2/n-1)*(n-3/n-2)*...*(n-i+1/n-i+2)*(1/n-i+1) = 1/n
		+ **算法步骤**: Knuth-Durstenfeld Shuffle
			+ 1、建立一个数组大小为 n 的数组，分别存放 1 到 n 的数值；
			+ 2、生成一个从 0 到 n-1 的随机数 x；
			+ 3、将数组的尾元素与数组索引为x的元素互换；
			+ 4、然后，生成一个从0 到 n-2 的随机数 x；
			+ 5、将数组的倒数第2个元素与数组索引为x的元素互换；
			+ 6、重复上述步骤，直至输出 m 个数为止。
		+ **证明**：每个数等概率出现
			+ 对于最后一个位置来说(第一次交换的随机数就是 i )：1/n
			+ 对于倒数第二个位置来说(第一次交换的随机数不是 i，第二次为 i)：((n-1)/n) * (1/(n-1)) = 1/n
			+ 对于第 n-k 个位置来说(前n-k+1次都不为 i，最后一次为 i)：((n-1)/n)*((n-2)/(n-1))*...*((n-k+1)/(n-k+2))*(1/(n-k+1)) = 1/n
		+ **代码**
			```python
			def shuffle(x):
				from random import random
				for i in reversed(range(1, len(x))):    # 从尾到头
					# pick an element in x[:i+1] with which to exchange x[i]
					j = int(random() * (i+1))    # 从索引为0到当前索引中随机选择一个索引
					x[i], x[j] = x[j], x[i]      # 并将随机选取的索引与当前索引指向的元素互换
   			```
+ 有2个鸡蛋，以及100层的楼，如果鸡蛋在第n层楼摔下去会碎，在n-1层楼摔下去不会碎，那么鸡蛋的硬度是n，鸡蛋碎了就不能使用了，没碎可以重复使用，请问在最坏情况下最少需要测试几次？
	+ 参考https://zhuanlan.zhihu.com/p/39816314
	+ 一般性思考：二分查找
  	+ 递归法：f(100) = max(f(100-k),k-1)+1

+ 掷硬币十次，得到结果为 8 个正面和 2 个反面。如何分析一枚硬币是否公平?p 值是什么?

+ 你有 10 个硬币。你每掷硬币 10 次(共 100 次)并观察结果。你会修改你的方法来测试硬币的公平性吗?
+ 从 100 个硬币中随机抽取一枚硬币：1 枚不公平的硬币(都是正面)，99 枚公平的硬币(一正一反)并投掷 10 次。如果结果是 10 个正面，那么这枚硬币是不公平的概率为多少?
+ 你即将坐飞机去西雅图。你想知道你是否应该带一把雨伞。你可以给 3 个随机的朋友打电话，每个人都会独立询问是否下雨。你的每个朋友都有三分之二的机会告诉你真相，并有三分之一的机会通过撒谎与你打交道。所有 3 位朋友都告诉你正在下雨。在西雅图实际下雨的可能性有多大?(同微软的那道题)
+ 考虑一个有 2 名玩家 A 和 B 的比赛。A 有 8 个棋子，B 有 6 个棋子。比赛进行如下。首先，A 滚动一个公平的六面模具，并且模具上的数字决定 A 从 B 接收多少个宝石。接下来，B 滚动相同的模具，并且完全相同的事情发生在相反的位置。本轮结束。谁在比赛结束时拥有更多的宝石则赢得比赛。如果玩家在回合结束时获得相同数量的宝石，则会形成平局并且接下来会有一轮。B 在 1，2，...，n 轮获胜的概率是多少?
+ 你在一个赌场掷色子，如果掷出 5 则赢，并获得 10 美元的奖金。你能赚多少?如果你一直玩到你赢了 (不管花多长时间)，那么你的预期支出是多少?
+ 三个朋友告诉你今天会下雨，他们中每个人都有三分之一的概率说谎，那么今天下雨的可能性是多少?

+ 设计一个抢红包的金额分配方案:
	+ 问题：
		+ 1、已有随机数生成函数 double rand()，返回[0,1)之间的double
		+ 2、输入总金额(double类型)，红包数量 (int类型)
		+ 3、返回一个数组，每个元素为对应的红包金额，要求每个红包金额随机且有相同的数学期望（总金额/红包个数）
		+ 比如: 输入100元，2个红包，可以返回（0.01, 99.99）,也可以返回(12.00,88.00)...
	+ 答案
		+ 1.先搞个范围内的随机数生成器，金额数乘于100，取随机数对应范围内的小数，比如100的话，就是看0.0001到0.9999
		+ 2.先用生成器生成一个随机数，金额再减去这个随机数
		+ 3.更新第一步的范围生成器
		+ 4.循环n-1次

+ 给定一个字符串"01234567891011121314151617181920..."和 m,找出字符串m位置上的字符？
	```python
  	def solve(s,m):
    '''给定一个字符串s，s="01234567891011121314..."，将自然数拼接在一起的字符串，求第m个位置上的数字？'''
    if m <= 10:
        return m-1
    c = 1    # 统计m所处于的位置是处于0-9、10-99、100-999、...哪个区间
    k = 10   # 0-9、10-99、100-999，...每个区间对应的数字个数有10、100、1000、
    total = c*k
    while int(m/total)>0:
        c += 1
        if c > 2:
            k *= 10
        total += c*k*9
    print("total: ",total)
    print("c*k*9: ",c*k*9)
    m -= (total-c*k*9)      # 找到m所在的区间，并计算区间起始点的距离
    print("m: ",m)
    tmp = k + (m-1)//c     # 找到m对应的数字

    print("tmp: ",tmp)
    tmp1 = str(tmp)
    return tmp1[(m-1)%c]    # (m-1)%c找到结果值在数字tmp中所在的位置
 	```

